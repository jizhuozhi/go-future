package future

import (
	"sync/atomic"
)

{{- range $i := .Tuples }}
func Of{{len .TypeParams}}[{{range $j := .TypeParams}}{{if $j.NotFirst}}, {{end}}{{$j.Name}}{{end}} any]({{range $j := .FuncParams}}{{if $j.NotFirst}}, {{end}}{{$j.Name}} *Future[{{$j.Type}}]{{end}}) *Future[{{.TupleType}}] {
	var done uint32
	s := &state[{{.TupleType}}]{}
	c := int32({{len .TypeParams}})
{{range $j := .ResVars}}
	var {{$j.Name}} {{$j.Type}}
{{- end}}

{{- $tuple := . -}}
{{range $j := .SubscribeBlocks}}
	{{$j.Future}}.state.subscribe(func(val {{$j.Type}}, err error) {
		if err != nil {
			if atomic.CompareAndSwapUint32(&done, 0, 1) {
				s.set({{$tuple.TupleType}}{}, err)
			}
		} else {
			{{$j.ResVar}} = val
			if atomic.AddInt32(&c, -1) == 0 {
				s.set({{$tuple.TupleType}}{ {{- range $k := $tuple.TupleVals}}{{if $k.NotFirst}}, {{end}}{{$k.Name}}{{end}} }, nil)
			}
		}
	})
{{- end}}

	return &Future[{{.TupleType}}]{state: s}
}
{{end}}